Overview: What problem is this codebase trying to solve?
What high-level assumptions are made in the codebase,
either about the background knowledge needed,
about what forms of extensibility are envisioned or are out of scope,
or about prerequisites for using this code?


Quick start: give a short snippet of code (rather like a simple JUnit test)
showing how a user might get started using this codebase.


Key components: Explain the highest-level components in your system, and what they do.
It is trite and useless to merely say “The model represents the data in my system.
The view represents the rendering of my system. ...” This is a waste of your time and the reader’s
time. Describe which components “drive” the control-flow of your system, and which ones “are driven”.


Key subcomponents: Within each component, give an overview of the main nouns in your system,
and why they exist and what they are used for.


Source organization: Either explain for each component where to find it in your codebase,
or explain for each directory in your codebase what components it provides. Either way, supply the
reader with a “map” to your codebase, so they can navigate around.

Overview
The Three Trios game is a two-player card game played on a customizable grid.
Players take turns placing cards on the grid and battling adjacent cards to flip them.
The game ends when all card cells are filled, and the winner is determined by counting owned cards.

Game Rules: The model assumes familiarity with the rules of Three Trios.
Extensibility: The design allows for future enhancements, such as AI players or variant rules.
Configuration Files: The game setup is customizable through external configuration files for grids
and cards.

Invariants:
  1. The number of card cells on the grid is always odd.
  2. The total number of the cards is the number of cells on the grid plus one and is constant.
  3. Each card cell is either empty or filled with one card.
  4. The size of each player's hand is always equal to or less than (N+1)/2,
     where N is the number of card cells on the grid.



Grid: Represents the layout of the game board, supporting various sizes and hole configurations.
Card: Represents individual cards with attack values for each direction (North, South, East, West).
Player: Manages player-specific information such as color and hand.
GameState: Central component that manages the game's rules, turn order, and win conditions.
ConfigurationReader: Utility class for reading grid and card configurations from files.


